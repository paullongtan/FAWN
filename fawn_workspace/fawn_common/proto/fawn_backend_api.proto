syntax = "proto3";

package fawn_backend_api;

service FawnBackendService {
    rpc Ping (PingRequest) returns (PingResponse);
    rpc GetValue (GetRequest) returns (GetResponse);
    // store value down the chain
    // new field: timestamp,pass_count
    // the backend should be responsible for passing the value down the chain for pass_count times
    // ex: for pass_count = 3, the backend should pass the value to the successor 3 times
    // for pass_count = 0, the backend should not pass the value down the chain
    rpc StoreValue (StoreRequest) returns (StoreResponse); 
    // for pre-copy stage, migrating data from old tail to new node
    // server-side streaming
    rpc MigrateData (MigrateDataRequest) returns (stream ValueEntry);
    // for final updata chain member stage, flushing data received after pre-copy stage from old tail to new node
    // the tail node should be responsible for documenting the data received after pre-copy stage
    // client-side streaming
    rpc FlushData (stream ValueEntry) returns (FlushDataResponse);
    // after pre-copy stage, updating the chain member
    rpc UpdateChainMember(ChainMemberInfo) returns (UpdateChainMemberResponse);
}

message NodeInfo {
    string ip = 1;
    uint32 port = 2;
    uint32 id = 3;
}

message ValueEntry {
    uint32 key_id = 1;
    bytes value = 2;
}

message PingRequest {
}

message PingResponse {
}

message GetRequest {
    uint32 key_id = 1;
}

message GetResponse {
    bytes value = 1;
}

message StoreRequest {
    uint32 key_id = 1;
    bytes value = 2;
    uint32 pass_count = 3; // how many times the value needs to be passed down the chain
}

message StoreResponse {
}
// need to maintain a log of what data has been sent to send over to new node after finalization
message MigrateDataRequest {
    NodeInfo dest_info = 1;
    uint32 start_id = 2;
    uint32 end_id = 3;
}

message FlushDataResponse {
}
// check if your predecessor is yourself, if so update your successor and call updatechainmember on successor
// check if you are successor of new node --> update your predecessor
// check if you are new node, you need to update both your predecessor and successor
// keep calling updatechain member down the chain, until you hit the old tail in which you flush to new node and send acks backwards
message ChainMemberInfo {
    NodeInfo predecessor = 1; // the predecessor of the new node should update its successor to the new node
    NodeInfo new_node = 2; // the new node
    NodeInfo successor = 3; // the successor of the new node should update its predecessor to the new node
    NodeInfo old_tail = 4; // the old tail node should flush the data received after pre-copy stage to the new node
}

message UpdateChainMemberResponse {
}